# TsClean-IoTDB-UDF
## 概述
本项目基于IoTDB的UDF，实现了TsClean数据质量系统的一系列重要函数，包括时序数据的特征计算、数值填补、数值修复等。

## 使用方式
+ 将本项目及其依赖打包成jar包
+ 将jar包复制到IoTDB文件夹的ext\udf目录下
+ 使用下面的SQL语句注册UDF

```sql
create function completeness as “cn.edu.thu.dquality.CompletenessUDF”
create function consistency as “cn.edu.thu.dquality.ConsistencyUDF”
create function timeliness as “cn.edu.thu.dquality.TimelinessUDF”
create function validity as “cn.edu.thu.dquality.ValidityUDF”
```

### 项目打包


## 函数介绍

<!-- ### 数据特征函数
### interval

### variation

### speed

### speedchange -->

### 时序数据质量指标函数
对于时序数据的质量，我们制定了完整性、一致性、时效性、有效性四个指标来进行衡量。计算各个指标的UDF如下表：

|    函数名    |          输入序列类型          |                                                       属性参数                                                       | 输出序列类型 |                                                       功能描述                                                       |
| :----------: | :----------------------------: | :------------------------------------------------------------------------------------------------------------------: | :----------: | :------------------------------------------------------------------------------------------------------------------: |
| COMPLETENESS | INT32 / INT64 / FLOAT / DOUBLE | `window`：每一个窗口包含的数据点数目，最后一个窗口的数据点数目可能会不足。缺省情况下，全部输入数据都属于同一个窗口。 |    DOUBLE    | 将输入序列划分为若干个连续且不重叠的窗口，分别计算每一个窗口的完整性，并输出窗口第一个数据点的时间戳和窗口的完整性。 |
| CONSISTENCY  | INT32 / INT64 / FLOAT / DOUBLE | `window`：每一个窗口包含的数据点数目，最后一个窗口的数据点数目可能会不足。缺省情况下，全部输入数据都属于同一个窗口。 |    DOUBLE    | 将输入序列划分为若干个连续且不重叠的窗口，分别计算每一个窗口的一致性，并输出窗口第一个数据点的时间戳和窗口的一致性。 |
|  TIMELINESS  | INT32 / INT64 / FLOAT / DOUBLE | `window`：每一个窗口包含的数据点数目，最后一个窗口的数据点数目可能会不足。缺省情况下，全部输入数据都属于同一个窗口。 |    DOUBLE    | 将输入序列划分为若干个连续且不重叠的窗口，分别计算每一个窗口的时效性，并输出窗口第一个数据点的时间戳和窗口的时效性。 |
|   VALIDITY   | INT32 / INT64 / FLOAT / DOUBLE | `window`：每一个窗口包含的数据点数目，最后一个窗口的数据点数目可能会不足。缺省情况下，全部输入数据都属于同一个窗口。 |    DOUBLE    | 将输入序列划分为若干个连续且不重叠的窗口，分别计算每一个窗口的有效性，并输出窗口第一个数据点的时间戳和窗口的有效性。 |


例如：
```sql
select s1,completeness(s1),consistency(s1),timeliness(s1),validity(s1) from root.test.d1 where time <= 2020-01-01 00:00:30
```

结果：
```
+-----------------------------+---------------+-----------------------------+----------------------------+---------------------------+-------------------------+
|                         Time|root.test.d1.s1|completeness(root.test.d1.s1)|consistency(root.test.d1.s1)|timeliness(root.test.d1.s1)|validity(root.test.d1.s1)|
+-----------------------------+---------------+-----------------------------+----------------------------+---------------------------+-------------------------+
|2020-01-01T00:00:02.000+08:00|          100.0|                        0.875|          0.9333333333333333|         0.9333333333333333|       0.8833333333333333|
|2020-01-01T00:00:03.000+08:00|          101.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:04.000+08:00|          102.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:06.000+08:00|          104.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:08.000+08:00|          126.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:10.000+08:00|          108.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:14.000+08:00|          112.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:15.000+08:00|          113.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:16.000+08:00|          114.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:18.000+08:00|          116.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:20.000+08:00|          118.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:22.000+08:00|          120.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:26.000+08:00|          124.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:28.000+08:00|          126.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:30.000+08:00|            NaN|                         null|                        null|                       null|                     null|
+-----------------------------+---------------+-----------------------------+----------------------------+---------------------------+-------------------------+
Total line number = 15
It costs 0.212s
```


## 函数实现
### 数据质量指标
对于时序数据的质量，我们制定了如下四个指标来进行衡量，每一个指标都包含了一个或多个异常：


|    完整性    | 一致性 | 时效性 |      有效性      |
| :----------: | :----: | :----: | :--------------: |
| 数据丢失异常 | 过密点 | 延迟点 |     取值范围     |
|   空值异常   |        |        |   取值分布范围   |
|  特殊值异常  |        |        |   取值变化范围   |
|              |        |        | 取值变化速度范围 |

**完整性**采用如下的公式计算：
$$
Completeness=1-\frac{N_{null}+N_{special}+N_{miss}}{N+N_{miss}}
$$
其中，$N$是时间序列总的数据点数目，$N_{null}$是时间序列中值为空的数据点数目，$N_{special}$是时间序列中值为特殊值的数据点数目，$N_{miss}$是时间序列中丢失的数据点数目。




**一致性**采用如下的公式计算：
$$
Consistency=1-\frac{N_{redundancy}}{N}
$$
其中，$N$是时间序列总的数据点数目，$N_{redundancy}$是时间序列中过密的数据点数目。

**时效性**采用如下的公式计算：
$$
Timeliness=1-\frac{N_{late}}{N}
$$
其中，$N$是时间序列总的数据点数目，$N_{late}$是时间序列中延迟的数据点数目。


**有效性**采用如下的公式计算：
$$
Validity=1-\frac{N_{value}+N_{variation}+N_{speed}+N_{speedchange}}{4N}
$$
其中，$N$是时间序列总的数据点数目，$N_{value}$是违反取值范围约束的数据点数目，$N_{variation}$是违反取值变化约束的数据点数目，$N_{speed}$是违反速度约束的数据点数目，$N_{speedchange}$是违反速度变化约束的数据点数目（同一个数据点可能违反多项约束）。

基于原始数据value和它的时间戳time，可以计算它的变化variation、速度speed以及速度变化speedchange：
$$
variation_{i}=value_{i+1}-value_{i}\\
speed_{i}=\frac{value_{i+1}-value_{i}}{time_{i+1}-time_{i}}\\
speedchange_{i}=speed_{i+1}-speed_{i}
$$


当一个数据x与其中位数的偏差超过了三倍绝对中位差时，称作违背约束，即
$$
|x-mid(x)|> 3* mad(x)
$$

