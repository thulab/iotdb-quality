# TsClean-IoTDB
语言：[English](README.md) | 中文

## 概述
TsClean数据质量系统由清华大学大数据系统软件国家工程实验室自行研发，是一款具有国际领先水平的软件。该系统着眼于数据质量，致力于为工业大数据的应用提供坚实基础。目前，该系统已经在多个工业场景中得到广泛应用，受到用户的一致好评。

本项目基于[Apache IoTDB](https://github.com/apache/iotdb)的用户自定义函数(UDF)，实现了TsClean数据质量系统的一系列重要函数，包括时序数据的质量指标计算、数值填补、数值修复等。

## 快速开始
1. 将本项目及其依赖打包成jar包或直接[下载](proguard-target/udf-tsclean-0.1.0-jar-with-dependencies.jar)
2. 将jar包复制到IoTDB程序目录的`ext\udf`目录下
3. 在IoTDB中使用下面的SQL语句注册UDF

```sql
create function completeness as “cn.edu.thu.dquality.udf.UDTFCompleteness”
create function consistency as “cn.edu.thu.dquality.udf.UDTFConsistency”
create function timeliness as “cn.edu.thu.dquality.udf.UDTFTimeliness”
create function validity as “cn.edu.thu.dquality.udf.UDTFValidity”
create function previousfill as “cn.edu.thu.dquality.udf.UDTFPreviousFill”
create function linearfill as “cn.edu.thu.dquality.udf.UDTFLinearFill”
create function screenrepair as “cn.edu.thu.dquality.udf.UDTFScreenRepair”
create function lsgreedyrepair as “cn.edu.thu.dquality.udf.UDTFLsGreedyRepair”
```

<!-- ### 项目打包
环境准备：
+ Java >= 1.8 (目前 1.8、11和13已经被验证可用。请确保环境变量路径已正确设置)。
+ Maven >= 3.1 

具体流程：
+ 修改pom.xml文件中如下的项目依赖，使其与目标IoTDB服务器版本一致（IoTDB-0.12.0版本以上支持UDF功能）；  

```xml
<dependency>
    <groupId>org.apache.iotdb</groupId>
    <artifactId>iotdb-server</artifactId>
    <version>0.12.0-SNAPSHOT</version>
    <scope>provided</scope>
</dependency>
<dependency>
    <groupId>org.apache.iotdb</groupId>
    <artifactId>tsfile</artifactId>
    <version>0.12.0-SNAPSHOT</version>
    <scope>provided</scope>
</dependency>
```
+ 在项目根目录下，使用下面的命令进行打包：  

```
mvn clean package -DskipTests
```
+ 执行完成后，包含依赖的jar包位于`target/udf-tsclean-0.1.0-jar-with-dependencies.jar`。 -->

## 函数介绍

### 时序数据质量指标函数
对于时序数据的质量，我们制定了完整性、一致性、时效性、有效性四个指标来进行衡量。计算各个指标的UDF如下表：

|    函数名    |          输入序列类型          |                                                       属性参数                                                       | 输出序列类型 |                                                       功能描述                                                       |
| :----------: | :----------------------------: | :------------------------------------------------------------------------------------------------------------------: | :----------: | :------------------------------------------------------------------------------------------------------------------: |
| COMPLETENESS | INT32 / INT64 / FLOAT / DOUBLE | `window`：每一个窗口包含的数据点数目，最后一个窗口的数据点数目可能会不足。缺省情况下，全部输入数据都属于同一个窗口。 |    DOUBLE    | 将输入序列划分为若干个连续且不重叠的窗口，分别计算每一个窗口的完整性，并输出窗口第一个数据点的时间戳和窗口的完整性。 |
| CONSISTENCY  | INT32 / INT64 / FLOAT / DOUBLE | `window`：每一个窗口包含的数据点数目，最后一个窗口的数据点数目可能会不足。缺省情况下，全部输入数据都属于同一个窗口。 |    DOUBLE    | 将输入序列划分为若干个连续且不重叠的窗口，分别计算每一个窗口的一致性，并输出窗口第一个数据点的时间戳和窗口的一致性。 |
|  TIMELINESS  | INT32 / INT64 / FLOAT / DOUBLE | `window`：每一个窗口包含的数据点数目，最后一个窗口的数据点数目可能会不足。缺省情况下，全部输入数据都属于同一个窗口。 |    DOUBLE    | 将输入序列划分为若干个连续且不重叠的窗口，分别计算每一个窗口的时效性，并输出窗口第一个数据点的时间戳和窗口的时效性。 |
|   VALIDITY   | INT32 / INT64 / FLOAT / DOUBLE | `window`：每一个窗口包含的数据点数目，最后一个窗口的数据点数目可能会不足。缺省情况下，全部输入数据都属于同一个窗口。 |    DOUBLE    | 将输入序列划分为若干个连续且不重叠的窗口，分别计算每一个窗口的有效性，并输出窗口第一个数据点的时间戳和窗口的有效性。 |


例如：
```sql
select s1,completeness(s1),consistency(s1),timeliness(s1),validity(s1) from root.test.d1 where time <= 2020-01-01 00:00:30
```

结果：
```
+-----------------------------+---------------+-----------------------------+----------------------------+---------------------------+-------------------------+
|                         Time|root.test.d1.s1|completeness(root.test.d1.s1)|consistency(root.test.d1.s1)|timeliness(root.test.d1.s1)|validity(root.test.d1.s1)|
+-----------------------------+---------------+-----------------------------+----------------------------+---------------------------+-------------------------+
|2020-01-01T00:00:02.000+08:00|          100.0|                        0.875|          0.9333333333333333|         0.9333333333333333|       0.8833333333333333|
|2020-01-01T00:00:03.000+08:00|          101.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:04.000+08:00|          102.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:06.000+08:00|          104.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:08.000+08:00|          126.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:10.000+08:00|          108.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:14.000+08:00|          112.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:15.000+08:00|          113.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:16.000+08:00|          114.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:18.000+08:00|          116.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:20.000+08:00|          118.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:22.000+08:00|          120.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:26.000+08:00|          124.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:28.000+08:00|          126.0|                         null|                        null|                       null|                     null|
|2020-01-01T00:00:30.000+08:00|            NaN|                         null|                        null|                       null|                     null|
+-----------------------------+---------------+-----------------------------+----------------------------+---------------------------+-------------------------+
Total line number = 15
It costs 0.212s
```

### 时序数据数值填补函数
对于时序数据，我们设计了一系列数值填补方法。各方法的UDF如下表：

|    函数名    |  输入序列类型  |                                                                                                                          属性参数                                                                                                                          |       输出序列类型       |                                         功能描述                                         |
| :----------: | :------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------: | :--------------------------------------------------------------------------------------: |
| PREVIOUSFILL | FLOAT / DOUBLE |                                                                `beforeRange`：只有当前一个非`NaN`数据点与当前数据点的时间差不超过该值时才会进行填补，否则仍为`NaN`。在缺省情况下为无穷大。                                                                 | 与输入序列的实际类型一致 |          将输入序列中的`NaN`填补为前一个非`NaN`数据点的值，输出填补后的新序列。          |
|  LINEARFILL  | FLOAT / DOUBLE | `beforeRange`：只有当前一个非`NaN`数据点与当前数据点的时间差不超过该值时才会进行填补，否则仍为`NaN`。在缺省情况下为无穷大。<br> `afterRange`：只有当后一个非`NaN`数据点与当前数据点的时间差不超过该值时才会进行填补，否则仍为`NaN`。在缺省情况下为无穷大。 | 与输入序列的实际类型一致 | 将输入序列中的`NaN`填补为前一个和后一个非`NaN`数据点线性插值的结果，输出填补后的新序列。 |

例如：
```sql
select s2,previousfill(s2,"beforeRange"="1000"),linearfill(s2,"beforeRange"="1000","afterRange"="1000") from root.test.d1 where time <= 2020-01-01 00:00:30
```

结果：
```
+-----------------------------+---------------+---------------------------------------------------+----------------------------------------------------------------------+
|                         Time|root.test.d1.s2|previousfill(root.test.d1.s2, "beforeRange"="1000")|linearfill(root.test.d1.s2, "beforeRange"="1000", "afterRange"="1000")|
+-----------------------------+---------------+---------------------------------------------------+----------------------------------------------------------------------+
|2020-01-01T00:00:00.000+08:00|            NaN|                                                NaN|                                                                   NaN|
|2020-01-01T00:00:01.000+08:00|          120.0|                                              120.0|                                                                 120.0|
|2020-01-01T00:00:02.000+08:00|          120.0|                                              120.0|                                                                 120.0|
|2020-01-01T00:00:04.000+08:00|            NaN|                                                NaN|                                                                   NaN|
|2020-01-01T00:00:05.000+08:00|          130.0|                                              130.0|                                                                 130.0|
|2020-01-01T00:00:06.000+08:00|            NaN|                                              130.0|                                                                 135.0|
|2020-01-01T00:00:07.000+08:00|          140.0|                                              140.0|                                                                 140.0|
+-----------------------------+---------------+---------------------------------------------------+----------------------------------------------------------------------+
Total line number = 7
It costs 0.421s
```
### 时序数据数值修复函数
时序数据中可能存在一些数值异常点，我们设计了一系列数值修复方法对这些异常点进行修复。各方法的UDF如下表：

|     函数名     |          输入序列类型          |                                                                                               属性参数                                                                                                |       输出序列类型       |                                                       功能描述                                                        |
| :------------: | :----------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------: | :-------------------------------------------------------------------------------------------------------------------: |
|  SCREENREPAIR  | INT32 / INT64 / FLOAT / DOUBLE | `minSpeed`：当速度小于该值时会被视作数值异常点加以修复。在缺省情况下为中位数减去三倍绝对中位差。<br> `maxSpeed`：当速度大于该值时会被视作数值异常点加以修复。在缺省情况下为中位数加上三倍绝对中位差。 | 与输入序列的实际类型一致 |    采用基于速度阈值的Screen方法对时间序列的数值进行修复，输出修复后的序列（`NaN`在修复之前会先进行线性插值填补）。    |
| LSGREEDYREPAIR | INT32 / INT64 / FLOAT / DOUBLE |                             `center`：对速度变化分布建立的高斯模型的中心。在缺省情况下为0。<br> `sigma`：对速度变化分布建立的高斯模型的标准差。在缺省情况下为绝对中位差。                             | 与输入序列的实际类型一致 | 采用基于速度变化似然的LsGreedy方法对时间序列的数值进行修复，输出修复后的序列（`NaN`在修复之前会先进行线性插值填补）。 |


例如：
```sql
select s1,screenrepair(s1),lsgreedyrepair(s1) from root.test.d1 where time <= 2020-01-01 00:00:30
```

结果：
```
+-----------------------------+---------------+-----------------------------+-------------------------------+
|                         Time|root.test.d1.s1|screenrepair(root.test.d1.s1)|lsgreedyrepair(root.test.d1.s1)|
+-----------------------------+---------------+-----------------------------+-------------------------------+
|2020-01-01T00:00:02.000+08:00|          100.0|                        100.0|                          100.0|
|2020-01-01T00:00:03.000+08:00|          101.0|                        101.0|                          101.0|
|2020-01-01T00:00:04.000+08:00|          102.0|                        102.0|                          102.0|
|2020-01-01T00:00:06.000+08:00|          104.0|                        104.0|                          104.0|
|2020-01-01T00:00:08.000+08:00|          126.0|                        106.0|                          106.0|
|2020-01-01T00:00:10.000+08:00|          108.0|                        108.0|                          108.0|
|2020-01-01T00:00:14.000+08:00|          112.0|                        112.0|                          112.0|
|2020-01-01T00:00:15.000+08:00|          113.0|                        113.0|                          113.0|
|2020-01-01T00:00:16.000+08:00|          114.0|                        114.0|                          114.0|
|2020-01-01T00:00:18.000+08:00|          116.0|                        116.0|                          116.0|
|2020-01-01T00:00:20.000+08:00|          118.0|                        118.0|                          118.0|
|2020-01-01T00:00:22.000+08:00|          120.0|                        120.0|                          120.0|
|2020-01-01T00:00:26.000+08:00|          124.0|                        124.0|                          124.0|
|2020-01-01T00:00:28.000+08:00|          126.0|                        126.0|                          126.0|
|2020-01-01T00:00:30.000+08:00|            NaN|                        128.0|                          128.0|
+-----------------------------+---------------+-----------------------------+-------------------------------+
Total line number = 15
It costs 0.766s
```
## 函数实现
### 数据质量指标
对于时序数据的质量，我们制定了如下四个指标来进行衡量，每一个指标都包含了一个或多个异常：


|    完整性    | 一致性 | 时效性 |    有效性    |
| :----------: | :----: | :----: | :----------: |
| 数据丢失异常 | 过密点 | 延迟点 |   取值范围   |
|   空值异常   |        |        | 取值变化范围 |
|  特殊值异常  |        |        |   速度范围   |
|              |        |        | 速度变化范围 |

**完整性**采用如下的公式计算：

Completeness = 1 - (N<sub>null</sub> + N<sub>special</sub> + N<sub>miss</sub>) / (N + N<sub>miss</sub>)


其中，N是时间序列总的数据点数目，N<sub>null</sub>是时间序列中值为空的数据点数目，N<sub>special</sub>是时间序列中值为特殊值的数据点数目，N<sub>miss</sub>是时间序列中丢失的数据点数目。


**一致性**采用如下的公式计算：


Consistency = 1 - N<sub>redundancy</sub> / N

其中，N是时间序列总的数据点数目，N<sub>redundancy</sub>是时间序列中过密的数据点数目。

**时效性**采用如下的公式计算：

Timeliness = 1 - N<sub>late</sub> / N

其中，N是时间序列总的数据点数目，N<sub>late</sub>是时间序列中延迟的数据点数目。


**有效性**采用如下的公式计算：

Validity = 1 - (N<sub>value</sub> + N<sub>variation</sub> + N<sub>speed</sub> + N<sub>speedchange</sub>) / (4 * N)

其中，N是时间序列总的数据点数目，N<sub>value</sub>是违反取值范围约束的数据点数目，N<sub>variation</sub>是违反取值变化约束的数据点数目，N<sub>speed</sub>是违反速度约束的数据点数目，N<sub>speedchange</sub>是违反速度变化约束的数据点数目（同一个数据点可能违反多项约束）。

基于原始数据value和它的时间戳time，可以计算它的变化variation、速度speed以及速度变化speedchange：

variation<sub>i</sub> = value<sub>i+1</sub> - value<sub>i</sub>

speed<sub>i</sub> = (value<sub>i+1</sub> - value<sub>i</sub>) / (time<sub>i+1</sub> - time<sub>i</sub>)

speedchange<sub>i</sub> = speed<sub>i+1</sub> - speed<sub>i</sub>


对序列x，当x<sub>i</sub>与其中位数的偏差超过了三倍绝对中位差（为了达到渐进正态性，乘上比例因子1.4826）时，称作违背约束，即

abs(x<sub>i</sub> - mid(x)) > 3 * mad(x)

### 数据填补方法

如果待填补的数据点的时间戳是t，前一个非`NaN`的数据点是(t<sub>1</sub>,v<sub>1</sub>)，后一个非`NaN`的数据点是(t<sub>2</sub>,v<sub>2</sub>)。那么，采用**Previous**方法进行填补的结果为：

v = v<sub>1</sub>

采用**Linear**方法进行填补的结果为：

v = v<sub>1</sub> + (t - t<sub>1</sub>) * (v<sub>2</sub> - v<sub>1</sub>) / (t<sub>2</sub> - t<sub>1</sub>)

### 数据修复方法

**Screen**方法是一种基于速度阈值的修复方法。它的核心思想是，在修改尽可能少的数据点的前提下，使整个时间序列的速度都不超过阈值。由于考虑全局约束的算法复杂度过大，这里将约束放松到一个滑动窗口内，结合候选范围与中位原则确定合适的修复方案。具体算法参见[SIGMOD'15-Screen](https://dl.acm.org/doi/10.1145/2723372.2723730)。

**LsGreedy**方法是一种基于速度变化似然的修复方法。它的核心思想是，对速度变化分布进行建模，并找到使似然函数最大化的修复方案。一般地，模型可以被视作高斯模型。为了降低运算复杂度，这里采用贪心算法寻找较优的修复方案。减小速度变化与中心的偏移可以增大似然函数。利用大根堆维护序列的速度变化，找到与高斯分布中心偏移最大的，并对其进行调整，使其更加接近中心。当所有的速度变化与中心的偏移都小于3倍标准差时，贪心算法终止。具体算法参见[SIGMOD'16-Sequential](https://dl.acm.org/doi/10.1145/2882903.2915233)。