(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{417:function(t,e,a){"use strict";a.r(e);var s=a(45),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"fft-todo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fft-todo"}},[t._v("#")]),t._v(" FFT(TODO)")]),t._v(" "),a("h2",{attrs:{id:"usage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usage"}},[t._v("#")]),t._v(" Usage")]),t._v(" "),a("p",[t._v("This function is used to calculate the fast Fourier transform (FFT) of a numerical series.")]),t._v(" "),a("p",[a("strong",[t._v("Name:")]),t._v(" FFT")]),t._v(" "),a("p",[a("strong",[t._v("Input:")]),t._v(" Only support a single input series. The type is INT32 / INT64 / FLOAT / DOUBLE.")]),t._v(" "),a("p",[a("strong",[t._v("Parameters:")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("type")]),t._v(": The type of FFT, which is 'uniform' (by default) or 'nonuniform'. If the value is 'uniform', the timestamps will be ignored and all data points will be regarded as equidistant. Thus, the equidistant fast Fourier transform algorithm will be applied. If the value is 'nonuniform', the non-equidistant fast Fourier transform algorithm will be applied based on timestamps.")]),t._v(" "),a("li",[a("code",[t._v("result")]),t._v(": The result of FFT, which is 'real', 'imag', 'abs' or 'angle', corresponding to the real part, imaginary part, magnitude and phase angle. By default, the magnitude will be output.")])]),t._v(" "),a("p",[a("strong",[t._v("Output:")]),t._v(" Output a single series. The type is DOUBLE. The timestamps starting from 0 only indicate the order.")]),t._v(" "),a("p",[a("strong",[t._v("Note:")]),t._v(" "),a("code",[t._v("NaN")]),t._v(" in the input series will be ignored.")]),t._v(" "),a("h2",{attrs:{id:"examples"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[t._v("#")]),t._v(" Examples")])])}),[],!1,null,null,null);e.default=r.exports}}]);