(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{478:function(t,r,a){"use strict";a.r(r);var s=a(45),n=Object(s.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"fft-todo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fft-todo"}},[t._v("#")]),t._v(" FFT(TODO)")]),t._v(" "),a("h2",{attrs:{id:"函数简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数简介"}},[t._v("#")]),t._v(" 函数简介")]),t._v(" "),a("p",[t._v("本函数对输入序列进行快速傅里叶变换。")]),t._v(" "),a("p",[a("strong",[t._v("函数名：")]),t._v(" FFT")]),t._v(" "),a("p",[a("strong",[t._v("输入序列：")]),t._v(" 仅支持单个输入序列，类型为 INT32 / INT64 / FLOAT / DOUBLE")]),t._v(" "),a("p",[a("strong",[t._v("参数：")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("type")]),t._v("：傅里叶变换的类型，取值为'uniform'或'nonuniform'，缺省情况下为'uniform'。当取值为'uniform'时，时间戳将被忽略，所有数据点都将被视作等距的，并应用等距快速傅里叶算法；当取值为'nonuniform'时，将根据时间戳应用非等距快速傅里叶算法。")]),t._v(" "),a("li",[a("code",[t._v("result")]),t._v("：傅里叶变换的结果，取值为'real'、'imag'、'abs'或'angle'，分别对应于变换结果的实部、虚部、模和幅角。在缺省情况下，输出变换的模。")])]),t._v(" "),a("p",[a("strong",[t._v("输出序列：")]),t._v(" 输出单个序列，类型为DOUBLE。序列的时间戳从0开始，仅用于表示顺序。")]),t._v(" "),a("p",[a("strong",[t._v("提示：")]),t._v(" 输入序列中的"),a("code",[t._v("NaN")]),t._v("将被忽略。")]),t._v(" "),a("h2",{attrs:{id:"使用示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用示例"}},[t._v("#")]),t._v(" 使用示例")])])}),[],!1,null,null,null);r.default=n.exports}}]);